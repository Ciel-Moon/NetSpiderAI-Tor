import pika
import json
import time
import threading
from queue import Queue
from typing import Callable, Dict, Any
from utils.logger import get_logger
from config import settings

logger = get_logger(__name__)

class DistributedScheduler:
    def __init__(self, host: str = settings.RABBITMQ_HOST, queue_name: str = settings.RABBITMQ_QUEUE):
        self.host = host
        self.queue_name = queue_name
        self.connection = None
        self.channel = None
        self.result_queue = Queue()

    def connect(self):
        """Establish connection to RabbitMQ."""
        self.connection = pika.BlockingConnection(pika.ConnectionParameters(host=self.host))
        self.channel = self.connection.channel()
        self.channel.queue_declare(queue=self.queue_name, durable=True)

    def add_task(self, url: str, priority: int = 5, **kwargs):
        """Submit a crawl task."""
        task = {
            'url': url,
            'priority': priority,
            'kwargs': kwargs,
            'timestamp': time.time()
        }
        self.channel.basic_publish(
            exchange='',
            routing_key=self.queue_name,
            body=json.dumps(task),
            properties=pika.BasicProperties(
                delivery_mode=2,  # persistent
                priority=priority
            )
        )
        logger.info(f"Task added: {url}")

    def start_worker(self, worker_id: str, crawl_func: Callable):
        """Start a worker that consumes tasks."""
        def callback(ch, method, properties, body):
            task = json.loads(body)
            logger.info(f"Worker {worker_id} processing: {task['url']}")
            try:
                result = crawl_func(task['url'], **task.get('kwargs', {}))
                ch.basic_ack(delivery_tag=method.delivery_tag)
                self.result_queue.put({
                    'task': task,
                    'result': result,
                    'worker': worker_id
                })
            except Exception as e:
                logger.error(f"Worker {worker_id} failed: {e}")
                ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)

        self.channel.basic_qos(prefetch_count=1)
        self.channel.basic_consume(queue=self.queue_name, on_message_callback=callback)
        logger.info(f"Worker {worker_id} started, waiting for tasks...")
        self.channel.start_consuming()

    def close(self):
        if self.connection:
            self.connection.close()
